## ReactとWebAudio API, useRef, useEffect
WebAudioAPIのコアロジックはReactとは独立。
いつ、どのコンポーネントのライフサイクルでWebAudioの初期化処理などを実行するか。
基本は、特定のReactコンポーネントが表示された時に初期化し、不要になった時にクリーンアップしたい。
→この、コンポーネントのライフサイクルに合わせて処理を行ってくれるのがHook(useState, useRef, useEffect, etc)。

### Reactにおける再レンダリング
useStateなどで管理している状態が更新されると、Reactはコンポーネント関数を再実行する。これが再レンダリング。
関数が再実行されるので、関数スコープ内の通常変数は一度削除される。

### Hook（useRef, useState）の出番
ここで、コンポーネントの再レンダリング時に、特定の値を保持したい場合などが問題になる。
再レンダリングを跨いで値を保持したい場合(ex.時間経過で増えていく値を保持したいとき)、useStateやuseRefなどの特別な関数を用いる。
useStateやuseRefなどが返す値はReact自体がコンポーネントの外側で管理・保持しているため、コンポーネント関数が再実行されても、値が保持される。

### useState, useRef
useRefは再レンダリングの影響を受けずに値を保持し続けるための箱みたいな感じ。
useStateとの違いは、useRefの値(currentプロパティ)を変更しても再レンダリングを引き起こさない点。
UIの表示に関係ない値(WebAudio APIのAudioContext)を、再レンダリングを跨いで保持したい場合に便利。

### useEffect
ここまで来て、WebAudio APIの初期化処理をどこに書くのかという問題がある。WebAudio APIの値は際レンダリングを跨いで保持できるけど、関数コンポーネント内で普通に初期化処理をしたら、結局再レンダリング時にまた初期化されてしまう。
また、関数外で初期化処理をした場合はそのコンポーネントが使われていなくても無駄なAudioContextが作られてしまうし、コンポーネントが不要になった時にクリーンアップが難しくなる。
コンポーネントの際レンダリングとは無関係に、コンポーネントのライフサイクルの中で一度だけ初期化処理をしたい。
→useEffectの出番。

useEffect(関数を返す関数、配列)
配列で指定されたタイミングで関数が実行され、コンポーネントが不要になった時に関数でreturnされた関数が実行される。


## 減算方式シンセサイザーの機能要件  
1. 音源部
   - オシレーター  
        - 波形選択(Sine, Square, Sawtooth, Triangle)  
        - オクターブ切り替え  
        - ファインチューン(細かい音程調節)  
        
3. 音加工  
    - フィルターセクション  
        - ローパスフィルター/ハイパスフィルター  
        - カットオフ周波数の制御  
        - (レゾナンス) ->　理解度浅いのでできれば実装する程度  
4. 音量制御  
    - エンベロープ  
        - ADSRでの音量制御  
    - マスターボリューム  
5. モジュレーション  
    - フィルターエンベロープ(フィルターのカットオフ周波数の時間変化を制御するADSRエンベロープ)  
    - LFO  
        - 波形選択(Triangle, Square, Sine)  
        - 周期の調整  
        - 適用先(オシレーターのピッチ、フィルターカットオフ周波数)  
6. 入出力  
    - 入力  
        - キーボード入力  
        - MIDI入力  
    - オーディオ出力  
        - 最終的にはステレオ出力したい。  


UIについて  
・オシレーターセクション  
・フィルターセクション  
・エンベロープセクション  
・モジュレーションセクション  

スライダーやノブなどで直感的に操作できるようにしたい  

波形生成とか音声信号処理とかの実装メインにしようと思ったけど、WwebAudio APIという便利なものがあったので、ウェブ関連の技術を習得することを第一目標にした。 